# 함수로 프로그래밍 하기 
## 안전한 프로그램 작성하는 비법 
 - 계산시 순수함수만 사용 
 - 계산결과를 외부세계에 사용하려면 순수 효과만 사용 
## 순수함수를 사용하지 않으면?
 - 프로그램이 비결정적이기떄문에 프로그램 절대적인 검사가 어렵다. (값이 어떻게 도출될지 예측이 어렵다는 뜻)
## 순수하지 않는 효과 
 - 효과 와 계산이 한 함수(메서드)내에 공존하는 형태를 의미
 - 순수하지 않는 효과는 쉽게 테스트가 어려움 따라서 효과 와 계산을 분리해야함.

### 함수란? 
 - 함수는 수학적 개념 
 - 정의역 과 공역 사이에 어떤 조건을 만족시키는 대응 관계
 - 역함수는 함수의 반대개념이라 생각하면 될듯 (ex> f(x) A -> B f-1(x) = B -> A)

#### 함수의 조건
 - 정의역 모든 원소에 대해 함수가 정의 되어야한다. 
 - 정의역의 모든 원소는 반드시 공역의 한 값에만 대응해야함. (정의역은 무조건 공역에 1:1 하지만 공역은 여러개가 있을수있음)

#### 함수 합성 
 - f(x) = x * 2 , g(x) = x + 1 이라고 정의할때 f(g(x)) = f(x+1) = (x+1) * 2
 - g(f(x)) = g(x * 2) = (x * 2) + 1 
 - f(g(x)) 와 g(f(x)) 는 항상 같을수가 없고, 때로는 같을수도 있다. 

#### 커리한 함수 
 - f(x,y) = f(x)(y) = x + y= f(X) = g = g(y) = x + y 
 - f(3,5) = g(5) = 3 + 5 = 8 
   - 여기서 x는 변수가 아니고 상수가 된다. (불변)
 - 커링은 결국 튜플에 대한 (인자가 여럿인 함수) 변환을 적용해서 함수를 반환하는 함수로 바꾸는 과정이다. 
 - f(rate,price) = price / 100 * (100 + rate) 는 g(price,rate) = price / 100 * (100 + rate) 는 같아보인다. 
   - 위 식의 커링버전은 f(rate)(price) , g(price)(rate) 로 표현가능하다. 
     - f(rate) 는 rate는 유동변수 price는 불변 변수가 되고, g(price) price는 변수가 되고, rate는 불변이된다. 결국 이 식은 부분함수라고 정의할수있음. 

#### 효과가 없는 함수 = 순수함수 
 - 순수함수란? 
   - 외부세계의 어떤 요소도 변이시키지 않고(외부는 함수밖의 모든것 의미),인자도 변이시키지 않고, 오류가 발생해도 예외를 던지지 않는다. 
   - 순수함수는 예외나 그와 비슷한 어떤 값도 반환할수있다. 이때 예외등을 값으로 반환해줘야함. 
   - 로그로 남거거나 화면에 출력하거나 호출 스택을 거슬러 올라가며 예외 던지는 행위는 순수함수에서는 허용하지 않는다. 

### 코틀린 함수 
- 코틀린에서의 함수는 실제로 자바의 메서드와 동일 
- 코틀린에서 fun 키워드로 정의한건 순수함수임을 보장할수 없다. 

#### 순수함수가 되기 위한 조건 (중복 내용) 
 - 함수 외부의 어떤 것도 변이시켜서는 안된다. 내부에서 상태를 변이 시키더라도 그 상태를 외부에서 관찰할 수 없어야 한다. 
 - 인자를 변이 시켜서는 안된다. 
 - 예외나 오류를 던져서는 안된다. 
 - 항상 값을 반환해야한다. 
 - 인자가 같으면 항상 같은 결과를 내놓아야 한다. 


### fun vs 식
#### fun 사용하는 이유 
- 인자를 넘기고 그 인자에 따른 반환값을 얻는 일만 하는 경우 사용한다 

#### 식을 사용하는 이유 
- 함수를 데이터 취급할때 
- 함수에서 함수를 돌려줘야하는 경우 
- 변수, 맵 그 밖에 데이터 구조에 함수를 저장해야 하는 경우 

#### 익명함수를 사용하는 경우 와 이름이 있는 함수를 사용하는 함수를 사용하는 경우 
- 익명함수는 단 한번만 사용할때 사용해라 (단 한번만 작성할때이다. 인스턴스를 단 한개만 만드는 그런 개념이 아님)
  - 코틀린은 함수가 호출될때마다 항상 객체를 생성하지 않는다!!! 
  - 익명함수 객체를 생성하는 비용도 아주 싸다!! 
- 성능이나 재사용성을 고려한다면 이름있는 함수를 가능한 사용해라!

### 올바른 타입 사용하기 
- 프로그램을 더 안전하게 만드려면 강력한 타입을 사용해 컴파일러가 프로그램을 검사해 만들어야한다. (ex> price가 있는데, rate값을 곱해야하는데 그냥 더한다거나...?)
- 표준타입으로만 구성된 프로그램으로 만들면, 실행은 잘 되겠지만, 개발자의 실수 혹은 외부의 실수로 인한 버그가 발생할수도있다.  (런타임 시점 에러는 찾기가 쉽지 않다. 그리고 장애로 이어질수도있다.) 

### fold VS reduce 
- 시작하는 원소를 제공하느냐 (fold), 제공하지 않느냐 (reduce)
- 결과 타입이 컬렉션의 원소 타입과 동일하냐 (reduce), 다르냐 (fold)
- 컬렉션이 비어있으면 reduce 는 아무 결과도 내지 못하지만, fold는 시작원소를 결과로 리턴한다. 